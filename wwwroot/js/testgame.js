class Snippet {
    constructor(fileName, size) {
        for (let i = 0; i < size; ++i)
            this.sound.push(Snippet.audio(fileName));
    }
    static sounds = [];
    static audio(src) {
        const a = new Audio(src);
        //a.volume = Sound.volume * (1 / Sound.maxVolume);
        Snippet.sounds.push(a);
        return a;
    }
    sound = [];
    count = 0;
    play() {
        this.sound[++this.count % this.sound.length].play();
    }
}
class Sound {
    // static batHit = new Snippet("./sounds/hit.mp3", 6);
    static hit = Snippet.audio("./sounds/hit.mp3");
    static pop = Snippet.audio("./sounds/pop.mp3");
    static over = Snippet.audio("./sounds/over.mp3");
    static bubble = Snippet.audio("./sounds/bubble.mp3");
    static bubble2 = Snippet.audio("./sounds/bubble2.mp3");
}
class GamePad {
    static isConnected = false;
    static current = null;
    static previous = null;
    static GamePad = (() => {
        addEventListener("gamepadconnected", (event) => {
            GamePad.current = navigator.getGamepads()[0];
            GamePad.previous = GamePad.current;
            GamePad.isConnected = true;
        });
        addEventListener("gamepaddisconnected", (event) => {
            GamePad.isConnected = false;
        });
    })();
    static update() {
        if (GamePad.isConnected) {
            GamePad.previous = GamePad.current;
            GamePad.current = navigator.getGamepads()[0];
        }
    }
    static isDown(button) {
        return GamePad.isConnected && GamePad.current.buttons[button].pressed;
    }
    static isPressed(button) {
        return (GamePad.isConnected &&
            GamePad.current.buttons[button].pressed &&
            !GamePad.previous.buttons[button].pressed);
    }
    static value(button) {
        if (!GamePad.isConnected)
            return 0;
        else
            return GamePad.current.buttons[button].value;
    }
    static get angle() {
        if (GamePad.isConnected) {
            const x = GamePad.current.axes[0];
            const y = GamePad.current.axes[1];
            if (!(x > -0.15 && x < 0.15 && y > -0.15 && y < 0.15)) {
                const ang = Math.atan2(y, x);
                return ang;
            }
        }
        return null;
    }
}
class KeyState {
    isPressed;
    isReleased;
    constructor(isPressed, isReleased) {
        this.isPressed = isPressed;
        this.isReleased = isReleased;
    }
}
class Keyboard {
    static lastMessage = "";
    static Keyboard = (() => {
        addEventListener("keydown", Keyboard.keyDown);
        addEventListener("keyup", Keyboard.keyUp);
    })();
    static state = {};
    static keyDown(event) {
        const state = Keyboard.state[event.code];
        if (state === undefined)
            Keyboard.state[event.code] = new KeyState(true, true);
        else
            state.isPressed = true;

        // Multiple 'keyDown' events are generated by keyboard but only first one needs to be sent
        if (Keyboard.lastMessage !== "KeyDown") {
            Keyboard.lastMessage = "KeyDown";
            connection.invoke("KeyDown", event.code).catch(function (err) {
                console.error(err.toString());
            });
        }
    }
    static keyUp(event) {
        const state = Keyboard.state[event.code];
        state.isPressed = false;
        state.isReleased = true;

        Keyboard.lastMessage = "KeyUp";
        connection.invoke("KeyUp", event.code, game.localPlayer.y).catch(function (err) {
            console.error(err.toString());
        });

    }
    static isDown(key) {
        // returns true while the key is in the down position
        const state = Keyboard.state[key];
        if (state === undefined)
            return false;
        else
            return state.isPressed;
    }
    static isPressed(key) {
        // returns true only once when first depressed
        // must be released and re-pressed before returning true again
        const state = Keyboard.state[key];
        if (state === undefined)
            return false;
        if (state.isPressed && state.isReleased) {
            state.isReleased = false;
            return true;
        }
        else
            return false;
    }
}
class RemoteKeyboard {
    //static RemoteKeyboard = (() => {
    //    addEventListener("keydown", RemoteKeyboard.keyDown);
    //    addEventListener("keyup", RemoteKeyboard.keyUp);
    //})();
    static state = {};
    static keyDown(code) {
        console.log(`keyDown: ${code}`);
        const state = RemoteKeyboard.state[code];
        if (state === undefined)
            RemoteKeyboard.state[code] = new KeyState(true, true);
        else
            state.isPressed = true;
    }
    static keyUp(code, y) {
        console.log(`keyUp: ${code}  ${y}`);
        const state = RemoteKeyboard.state[code];
        state.isPressed = false;
        state.isReleased = true;

        game.remotePlayer.y = y;
    }
    static isDown(key) {
        // returns true while the key is in the down position
        const state = RemoteKeyboard.state[key];
        if (state === undefined)
            return false;
        else
            return state.isPressed;
    }
    static isPressed(key) {
        // returns true only once when first depressed
        // must be released and re-pressed before returning true again
        const state = RemoteKeyboard.state[key];
        if (state === undefined)
            return false;
        if (state.isPressed && state.isReleased) {
            state.isReleased = false;
            return true;
        }
        else
            return false;
    }
}
class GameInput {
    constructor(keyboards) { }
    static get isRemotePlayerUp() {
        return RemoteKeyboard.isDown("ArrowUp") || GamePad.isDown(12 /* UpJoyPad */);
    }
    static get isRemotePlayerDown() {
        return RemoteKeyboard.isDown("ArrowDown") || GamePad.isDown(13 /* DownJoyPad */);
    }
    static get isLocalPlayerUp() {
        return Keyboard.isDown("ArrowUp") || GamePad.isDown(3 /* Up */);
    }
    static get isLocalPlayerDown() {
        return Keyboard.isDown("ArrowDown") || GamePad.isDown(0 /* Down */);
    }
    static get isPaused() {
        return Keyboard.isPressed("KeyP") || GamePad.isPressed(9 /* Pause */);
    }
    static get isRestart() {
        return Keyboard.isPressed("KeyR") || GamePad.isPressed(8 /* Restart */);
    }
}
class Player {
    x = 0;
    y = 0;
    width = 5;
    height = 0;
    direction;
    score = 0;
    scoreX = 0;
    static speed = 2;
    isLocal = false;
    constructor(direction) {
        this.direction = direction;
        this.height = Game.vHeight / 12;
        if (direction === 1) {
            this.x = 50;
            this.scoreX = Game.vWidth * 0.25;
        }
        else {
            this.x = Game.vWidth - 50;
            this.scoreX = Game.vWidth * 0.75;
        }
        this.y = (Game.vHeight / 2) - (this.height / 2);
    }
    update(progress, counter) {
        let isPlayerUp;
        if (this.isLocal) isPlayerUp = GameInput.isLocalPlayerUp;
        else isPlayerUp = GameInput.isRemotePlayerUp;

        let isPlayerDown;
        if (this.isLocal) isPlayerDown = GameInput.isLocalPlayerDown;
        else isPlayerDown = GameInput.isRemotePlayerDown;

        if (this.direction === 1) {
            if (this.y > 0 && isPlayerUp)
                this.y -= Player.speed;
            if (this.y < Game.vHeight - this.height && isPlayerDown)
                this.y += Player.speed;
        }
        else {
            if (this.y > 0 && isPlayerUp)
                this.y -= Player.speed;
            if (this.y < Game.vHeight - this.height && isPlayerDown)
                this.y += Player.speed;
        }
    }
    draw() {
        Game.View.fillRect(this.x, this.y, this.width, this.height);
        let star = "";
        if (this.isLocal) star = "*"
        Game.View.fillText(`${this.score}${star}`, this.scoreX, 80);
    }
    get batRect() {
        return {
            left: this.x,
            right: this.x + this.width,
            top: this.y,
            bottom: this.y + this.height,
        };
    }
    isHit(ball) {
        const bat = this.batRect;
        return (ball.x >= bat.left &&
            ball.x <= bat.right &&
            ball.y >= bat.top &&
            ball.y <= bat.bottom);
    }
    get middleY() {
        return this.y + this.height * 0.5;
    }
}
class Ball {
    x = 0;
    y = 0;
    width = 5;
    height = 5;
    dx = 0;
    dy = 0;
    isDead = false;
    deadCount = 0;
    winner = null;
    constructor(player) {
        this.reset(player);
    }
    update(progress, counter) {
        if (this.isDead) {
            if (counter === 1 && ++this.deadCount > 100) {
                this.reset(this.winner);
            }
        }
        else {
            const dx = this.dx * progress;
            const dy = this.dy * progress;
            const x = this.x + dx;
            const y = this.y + dy;
            // detect winning ball (ball goes off left/right edge)
            if (x < 0 || x > Game.vWidth - this.width) {
                Sound.over.play();
                this.isDead = true;
                if (x < 0) {
                    this.winner = game.playerRight;
                    game.playerRight.score += 1;
                }
                else {
                    this.winner = game.playerLeft;
                    game.playerLeft.score += 1;
                }
            }
            // detect bounce off top/bottom
            if (y < 0 || y > Game.vHeight - this.height) {
                this.dy = -this.dy;
                Sound.pop.play();
            }
            // detect bounce off both bats
            if (this.dx > 0) {
                // detect bounce off right bat if right is local
                if (game.isRightLocal && game.playerRight.isHit(game.ball.middleRight)) {
                    this.dx = -this.dx;
                    // calc dy for new angle of ball
                    const paddleLevel = (this.middleY - game.playerRight.middleY) / game.playerRight.height;
                    this.dy = paddleLevel * 10;
                    Sound.bubble.play();

                    connection.invoke("UpdateBall", this.x, this.y, this.dx, this.dy).catch(e => console.error(e));
                }
            }
            else {
                // detect bounce off left bat only if left is local
                if (game.isLeftLocal && game.playerLeft.isHit(game.ball.middleLeft)) {
                    this.dx = -this.dx;
                    // calc dy for new angle of ball
                    const paddleLevel = (this.middleY - game.playerLeft.middleY) / game.playerLeft.height;
                    this.dy = paddleLevel * 10;
                    Sound.bubble.play();

                    connection.invoke("UpdateBall", this.x, this.y, this.dx, this.dy).catch(e => console.error(e));
                }
            }
            this.x += this.dx * progress;
            this.y += this.dy * progress;
        }
    }
    remoteUpdate(x, y, dx, dy) {
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
    }
    draw() {
        // draw ball
        if (!this.isDead) {
            Game.View.fillRect(this.x, this.y, this.width, this.height);
        }
        // draw dashed centre line
        const halfWay = Game.vWidth * 0.5;
        Game.View.beginPath();
        Game.View.setLineDash([10, 10]);
        Game.View.moveTo(halfWay, 0);
        Game.View.lineTo(halfWay, Game.vHeight);
        Game.View.stroke();
    }
    get middleRight() {
        return { x: this.x + this.width, y: this.y + this.height * 0.5 };
    }
    get middleLeft() {
        return { x: this.x, y: this.y + this.height * 0.5 };
    }
    get middleY() {
        return this.y + this.height * 0.5;
    }
    reset(player, newBallAngle = 0) {
        this.isDead = false;
        this.deadCount = 0;
        // this.x = player!.x;
        this.x = Game.vWidth / 2 - (this.width / 2);
        this.y = player.y + player.height * 0.5;
        this.dx = 5 * player.direction;
        this.dy = 10 * (newBallAngle - 0.5);
    }
}
class Game {
    static Canvas = document.querySelector("canvas");
    static View = Game.Canvas.getContext("2d");
    thisPlayer = null;
    static vWidth = 1000;
    static vHeight = 1000;
    static Game = (() => {
        addEventListener("resize", Game.resize);
    })();
    #previousTimestamp = 0;
    static isPaused = false;
    static resize() {
        //game.start();
        Game.Canvas.width = window.innerWidth;
        Game.Canvas.height = window.innerHeight;
        const xScale = window.innerWidth / Game.vWidth;
        const yScale = window.innerHeight / Game.vHeight;
        Game.View.scale(xScale, yScale);
        Game.View.fillStyle = "white";
        Game.View.strokeStyle = "white";
        const scale = (xScale + yScale) / 2;
        const fontSize = 40 / scale;
        Game.View.font = `${fontSize}px Lucida Console`;
    }
    // game objects
    playerLeft = null;
    playerRight = null;
    ball = null;
    update() {
        GamePad.update();
        if (GameInput.isPaused) {
            Game.isPaused = true;
            return;
        }
        const totalUpdates = 5;
        let counter = 1;
        const progress = 1 / totalUpdates;
        while (counter <= totalUpdates) {
            this.playerLeft?.update(progress, counter);
            this.playerRight?.update(progress, counter);
            this.ball?.update(progress, counter);
            counter += 1;
        }
        this.draw();
    }
    draw() {
        // clear the screen
        //const height = Game.Canvas.height;
        //const width = Game.Canvas.width;
        // Game.View.clearRect(0, 0, width, height);
        Game.View.clearRect(0, 0, Game.vWidth, Game.vHeight);


        // draw all game objects
        this.playerLeft.draw();
        this.playerRight.draw();
        this.ball.draw();
    }
    step(timestamp) {
        if (GameInput.isRestart) {
            Game.isPaused = false;
            game = new Game();
            game.start();
        }
        if (Game.isPaused) {
            // check for resume
            GamePad.update();
            if (GameInput.isPaused)
                Game.isPaused = false;
        }
        else {
            const framesPerSecond = 30;
            const delay = 1000 / (framesPerSecond + 1);
            const elapsed = timestamp - this.#previousTimestamp;
            if (elapsed > delay) {
                this.update();
                this.#previousTimestamp = timestamp;
            }
        }
        requestAnimationFrame(Game.animate);
    }
    get localPlayer() {
        return this.thisPlayer == "1" ? this.playerLeft : this.playerRight;
    }
    get remotePlayer() {
        return this.thisPlayer == "-1" ? this.playerLeft : this.playerRight;
    }
    get isLeftLocal() {
        return this.thisPlayer == "1";
    }
    get isRightLocal() {
        return this.thisPlayer == "-1";
    }
    start(thisPlayer, newBallAngle) {
        // start/setup logic
        //Game.Canvas.height = window.innerHeight;
        //Game.Canvas.width = window.innerWidth;
        Game.resize();


        this.thisPlayer = thisPlayer;
        this.playerLeft = new Player(1);
        this.playerRight = new Player(-1);

        if (thisPlayer == "1") {
            this.playerLeft.isLocal = true;
            this.playerRight.isLocal = false;
        } else {
            this.playerLeft.isLocal = false;
            this.playerRight.isLocal = true;
        }

        this.ball = new Ball(this.playerLeft, newBallAngle);
        this.ball.reset(this.playerLeft, newBallAngle);
        requestAnimationFrame(Game.animate);
    }
    static animate = (timestamp) => game.step(timestamp);
}

var game = new Game();
//game.start();

var connection = new signalR.HubConnectionBuilder().withUrl("/pinghub").configureLogging(signalR.LogLevel.Debug).build();

connection.on("StartPlay", (player, newBallAngle) => game.start(player, newBallAngle));
connection.on("KeyUp", RemoteKeyboard.keyUp);
connection.on("KeyDown", RemoteKeyboard.keyDown);
connection.on("UpdateBall", (x, y, dx, dy) => game.ball.remoteUpdate(x, y, dx, dy));

connection.start().then(function () {
    console.log("Connection successful");

    const newBallAngle = Math.random().toString();
    connection.invoke("JoinGame", newBallAngle).catch(e => console.error(e));

}).catch(e => console.error(`Failed to start connection: ${e}`));